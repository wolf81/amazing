local PATH = (...):match("(.-)[^%.]+$") 

local PriorityQueue = require(PATH .. '.pqueue')
local Map = require(PATH .. '.map')

-- not a number: indicates in a Dijkstra map that a tile is not reachable
local nan = 0/0

local mmin, mhuge = math.min, math.huge

--[[ DIJKSTRA ]]--

-- get neighbor tile positions based on x & y value
local function getNeighbors(x, y)
    return { 
        { x - 1, y },
        { x + 1, y },
        { x, y - 1 },
        { x, y + 1 },
        { x - 1, y - 1 },
        { x - 1, y + 1 },
        { x + 1, y - 1 },
        { x + 1, y + 1 },
    }
end

-- generate a key based on x & y value
-- a key is generated by moving y 16 bits to the left and adding x
local function getKey(x, y)
    return bit.lshift(y, 16) + x
end

-- return a Dijkstra map, based on the Dijkstra algorithm described here:
-- https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
local function map(tile_map, x, y, blocked)
    local map_w, map_h = tile_map.size()
    local start = { x = x, y = y }    
    local d_map = Map(map_w, map_h, mhuge)
    local unvisited = PriorityQueue()

    -- create an empty Dijkstra map, all tile distances are set to math.huge
    -- or nan if unreachable
    for x, y, _ in tile_map.iter() do
        if blocked(x, y) then
            d_map.set(x, y, nan)
        else
            d_map.set(x, y, mhuge)
            unvisited:enqueue(getKey(x, y), mhuge)
        end
    end

    -- set the start position by setting the tile distance value to 0
    d_map.set(start.x, start.y, 0)
    unvisited:update(getKey(start.x, start.y), 0)

    -- process all unvisited tiles
    while not unvisited:empty() do
        local key, dist = unvisited:dequeue()
        -- decode x and y value from the key
        local x = bit.band(key, 0xFF)
        local y = bit.rshift(key, 16)

        -- process each neighbor for current x and y value
        for _, neighbor in ipairs(getNeighbors(x, y)) do
            local n_x, n_y = unpack(neighbor)
            local n_key = getKey(n_x, n_y)

            -- if the neighbor tile was visited previously, skip
            if not unvisited:contains(n_key) then goto continue end

            -- calculate distance and update the unvisited neighbor tile
            local n_dist = mmin(d_map.get(n_x, n_y), dist + 1)
            unvisited:update(getKey(n_x, n_y), n_dist)

            ::continue::
        end

        -- since x and y position is now visited, remove from unvisited list
        unvisited:remove(key)

        -- update distance in Dijkstra map for the visited tile
        d_map.set(x, y, dist)
    end

    return d_map
end

return {
    map = map,
}
